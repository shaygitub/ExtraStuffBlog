---
title: "APC Mechanism Explained - continuation of DPC Mechanism Explained"
date: 2024-03-27
---

# APC(Asynchronous Procedure Call)-
A mechanism that lets a UM/KM thread to run in the context of a certain process, this mechanism does not have the 
main restrictions that a DPC has to deal with (an APC is allowed to call system services, generate page faults and
create/wait for dispatcher objects / other objects)



# APCs from a high level:
- In this case, each thread has an APC list to execute in its context (instead of a list per processor, makes sense as
  the purpose of the APC is to run in a specific context of a specific thread/process)
- When an APC is requested to be added, the kernel will perform a software interrupt as APC IRQL (APC_LEVEL) and add
  the APC to the APC list of the specific thread to run in its context (specified in KTHREAD.ApcState)
* similarly to the DPC lists, the APC list is also populated with structs/objects that describe the specific APC,
  specifically KAPC (i will talk about it and its attributes later on)
- When a context switch to that thread occurs the APCs for that thread will get executed one after the other (APCs also
  have inner prioritizing like DPCs but they will generally be run before any other code related to that thread)


# APCs can run in 2 different types of thread contexts:
1) UM thread context - any thread can request to add an APC to the list of a UM thread, but the kernel is limited in
  when he can insert a new APC into the list:
  - The relevant UM thread to run in the context of should signal to the kernel that its ready to accept new APCs
    by being in a wait state (unvoluntary - waiting for some kind of object handle / voluntary - using
    WaitForMultipleObjectsEx to signal a voluntary wait which can be used to add new APCs)
  - Afterwards the kernel would signal to the relevant thread that a new APC is being added to its list and let it
    know that it needs to execute that APC
2) KM thread context - mainly by requests from UM, as the kernel "is" the owner of that KM thread it can just
add that APC to the APC list of that KM thread


# The different types of APCs:
1) UserMode APCs - this is the "lowest" type of APC as every thread (UM threads and KM threads) could add such APC to
   a list of a certain thread and this APC will be processed last (see execution order of different APCs). these
   APCs also have to get permission from the relevant thread to add their APC or they would not be able to add it.
   these are used in many operations and syscalls such as ReadFileEx and WriteFileEx.
   
3) KernelMode APCs - these APCs do not need permission from the thread they want to execute
   in its context (they are superior to UM threads so it makes sense they will be able to, and as i said the kernel
   "is" the KM thread's owner). KM APCs are mostly used for thread suspension/termination/verification of different
   paramters and the execution context. There are also 2 types of kernel APCs:

     a) Special KM APCs - runs at APC_LEVEL IRQL, allows the manipulation of regular KM APCs existing in the list if needed, these will
     probably be used for purposes like to show results after an asynchronous operation has finished and its results
     need to be saved in the thread's address space and the results will need to affect the rest of the thread's
     execution accordingly.

     b) Normal KM APCs - this APC runs at PASSIVE_LEVEL IRQL and uses the parameters it was provided with (altered parameters if a special
     KM APC exists, else the original parameters for the operation).

* Note: a UserMode APC will only be removed from the list if the thread is not in a wait state anymore, meaning
  that the relevant thread could go into a wait state, receive an initiated APC to run and execute it and if the
  thread is still at a wait state when the APC finishes executing it will stay in the waiting list
* Another note: it is also possible to disable special KM APCs / normal KM APCs by entering a value in the
  SpecialApcDisable/KernelApcDisable respectively in the EHTHREAD structure of the relevant thread.
  

# Execution order of different APC types:
Execution order is described in this example -
![APC](https://github.com/shaygitub/ExtraStuffBlog/assets/122000611/dec2db58-3931-4b98-af02-7134289a37cb)


# The KAPC structure:

typedef struct _KAPC {
     // always 0x12 (ApcObject)
    UCHAR Type;
    UCHAR SpareByte0;

    // always the size of the structure 
    // (the correct size based on the architecture of the CPU)
    UCHAR Size; 
    UCHAR SpareByte1;
    ULONG SpareLong0;

    PKTHREAD Thread; 

    LIST_ENTRY ApcListEntry;  // APC entry in the relevant list

    //
    // Functions
    //
    PKKERNEL_ROUTINE KernelRoutine;
    PKRUNDOWN_ROUTINE RundownRoutine;
    PKNORMAL_ROUTINE NormalRoutine;

    //
    // Arguments
    //
    PVOID NormalContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;

    CCHAR ApcStateIndex;

    KPROCESSOR_MODE ApcMode;
    BOOLEAN Inserted;

} KAPC, *PKAPC;


# Analyzing the KAPC structure:

- Type & Size: Constant values that have to be there for kernel layer objects
- Thread: pointer to the EHTHREAD of the relevant thread
- ApcListEntry: a LIST_ENTRY structure that allows the kernel to store this APC in the target queue
- Function Pointers:
    - NORMAL_ROUTINE: runs in UM execution context after the APC is executed
    - KERNEL_ROUTINE: runs in KM execution context before the "official" finishing of the APC, is usually
      used for freeing memory at the end of the APC operation
    - RUNTIME_ROUTINE: runs in the case where the thread gets terminated before the APC gets executed by the
      thread, at this case the function usually frees memory that was supposed to be used by the APC
- NormalContext: the value of the user parameter - SystemArgument1
- SystemArgument1 - It contains the value of the user parameter - SystemArgument2
- SystemArgument2 - It contains the value of the user parameter - SystemArgument3
- Inserted: A boolean flag that tells if the APC was already inserted or not


# APC example number 1 - KeStackAttachProcess\KeStackDetachProcess:
this API function can be used to change execution context to the context of the target thread with the EPROCESS
object of the process for attaching / the APC_STATE object for the current thread execution context for detaching
example of usage - process injection from a KM driver:


# Usage example of KeStackAttachProcess\KeStackDetachProcess:
NTSTATUS KernelToUserMEM(PEPROCESS DstProcess, PVOID KernelAddress, PVOID UserAddress,
         SIZE_T Size, BOOL IsAttached) {
	DbgPrintEx(0, 0, "KMDFdriver Memory - Transfer data from KM to UM\n");
	KAPC_STATE DstState = { 0 };



	// Check for invalid parameters:
	if (DstProcess == NULL || KernelAddress == NULL || UserAddress == NULL || Size == 0) {
		DbgPrintEx(0, 0, "KMDFdriver Memory - Transfer data from KM to UM failed (one or more invalid parameters: %p, %p, %p, %zu)\n", (PVOID)DstProcess, KernelAddress, UserAddress, Size);
		return STATUS_INVALID_PARAMETER;
	}


	// Attach to the usermode process if needed:
	if (!IsAttached) {
		KeStackAttachProcess(DstProcess, &DstState);
	}


	// Perform the transfer:
	__try {
		ProbeForRead(UserAddress, Size, sizeof(UCHAR));
		RtlCopyMemory(UserAddress, KernelAddress, Size);
		if (!IsAttached) {
			KeUnstackDetachProcess(&DstState);
		}
		DbgPrintEx(0, 0, "KMDFdriver Memory - Transfer data from KM to UM succeeded\n");
		return STATUS_SUCCESS;
	}

	__except (STATUS_ACCESS_VIOLATION) {
		DbgPrintEx(0, 0, "KMDFdriver Memory - Transfer data from KM to UM failed (access violation kernel exception)\n");
		if (!IsAttached) {
			KeUnstackDetachProcess(&DstState);
		}
		return STATUS_ACCESS_VIOLATION;
	}
}


# APC example number 2 - KeDelayExecutionThread:
this APC call is used to delay the execution of the running thread. it creates a timer and when its time is concluded
the thread continues executing


# Credits:
most of this entry was based on the blog https://www.sysnative.com/forums/threads/dpcs-and-apcs.11076/, which helped
me understand these topics better. i also used
https://repnz.github.io/posts/apc/kernel-user-apc-api/#the-kapc-structure
for the KAPC analyzation
