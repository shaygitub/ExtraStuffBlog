---
title: "DPC Mechanism Explained"
date: 2024-03-27
---

# DPC(Deferred Procedure Call)-
A mechanism that was created for two main reasons:
1) limit deprivation of other processes as a result of a thread running at DISPATCH_LEVEL irql or higher for too long
2) Execute tasks at a specific time/interval (APCs have similar functionalities in this topic (i.e with KeDelayExecutionThread) but they will be explained next)
As you might know, when a process is running with a higher IRQL it will be executed before any other process from a lower IRQL. you can think about it like this:


# IRQL priority-defined execution sequence:

ProcessesToRun = [
[irql0_process1, irql0_process2, irql0_process3, irql0_process4 ..],
[irql1_process1, irql1_process2, irql1_process3, irql1_process4 ..],
[irql2_process1, irql2_process2, irql2_process3, irql2_process4 ..],
[irql3_process1, irql3_process2, irql3_process3, irql3_process4 ..],
...
]
- in this example sublist number 3 (irql3) will finish running, then sublist number 2, sublist number 1 and finally the first sublist (irql0) as a result of the IRQL.


this shows that if a process gets to a higher IRQL it will get more execution time than other processes, which might cause deprivation of execution time
for other processes
  
for this reason it is always recommended to use a higher IRQL only when you have to (i.e with physical addresses in a KM driver or with shared data structures)
and then lower it immediatelly, but because you cannot rely on this recommendation alone the DPC mechanism was implemented.


# DPCs from a high level:
- Each processor has a DPC list of its own
- A thread that requests to be dispatched at a higher IRQL level will be added to one of these lists accordingly as a structure instance
- When thread dispatching takes place the kernel requests a software interrupt to execute the thread, but masks the request so the processor will know to execute
  it only after more important operations / after already occuring operations
- ONLY after that specific processor finishes processing an occuring operation will it check its DPC list to see if any thread dispatching needs to take place,
  if the list is not empty it will go to IRQL DISPATCH_LEVEL, execute the threads with the context and other parameters specified in the thread entry and reduce its
   IRQL back to PASSIVE_LEVEL
this mechanism makes sense as a thread might need to run at a higher IRQL level, but is still less important than whats already executing


# DPC priorities:
DPCs have inner-priorities (low, medium, medium-high and high), which can determine when the DPC is executed and how it is added to the queue, by default device
  drivers set the DPC priority to medium but it can be changed. this is how DPC priorities affect the DPC list in the forn of Pseudo-Code:
    
    ProcessorDpcList = [ thread1_prhigh, thread2_prhigh,thread3_prmedium-high,thread4_prmedium-high,thread5_prmedium,thread6_prlow ]
    def adddpc(DpcObject):
      if DpcObject.priority == high:
        insert_to_beginning(DpcObject)
      elif DpcObject.Priority == medium-high:
        insert_after_high_in_list(DpcObject)
      ...
      else:
        insert_last_in_list(DpcObject)  // DPC priority == low

DPC list is organized by different sections (section 0 = high, section 1 = medium-high, section 2 = medium, section 3 = low) and each thread in each section
is put after the already existing threads


# Some other notes/specifications about DPCs:
- DPCs are general tasks to be executed at DISPATCH_LEVEL/higher IRQL, therefore DPCs do not run in the context of a particular thread being executed, as a result:
  - DPCs are not allowed to call system services, generate page faults and create/wait for dispatcher objects (only specific threads can perform
  these operations so as a generic and not-specified thread its logical).
  * Dispatcher objects - synchronisation mechanisms such as mutex, event, semaphore and timer objects that are relevant for thread dispatching
  - DPCs are allowed to access nonpaged memory (as most system/kernel level objects they are always mapped in the system address space - nonpaged memory)

- The actual DPC object/struct that is held in the DPC list mainly contains the code of the thread to execute when the processor is free to execute DPCs,
  specifically the most important attribute of a DPC object is the pointer to the thread in memory that's being executed WHILE THE DPC IS INITIATED,
  this is important because finding the location of the thread in memory is possible but it would deprive the whole system from execution time

- DPCs also have targeting capabilities (to choose on which processor the DPC will run) but most device drivers ignore this so processor 0 usually gets overwhelmed
  with DPCs to execute
- The process of executing each DPC from the list until the list is empty is called DPC draining. DPC draining only occurs in DPCs with a priority higher
  than "low", these only get executed when the amount of DPCs with a "low" priority for the specific processor is higher than a maxium number of low-priority DPCs
  to hold
- If the targeted CPU is different from the one executing the ISR (interrupt service routine, specifically here for thread dispatching) The current processor will
  send a request to the targeted processor for DPC draining (high/medium-high - IPI (Inter Processor Interrupt) to the targeted processor, medium/low - only
  if the amount of DPCs with a "low" priority for the specific processor is higher than a maxium number OR if the system is idle)
      

# Main disadvantage of DPCs:
The main problem with DPCs revolving around general system operations is that they don't run in the context of a particular thread so they do not care about 
what thread is currently executing (even the thread with the highest priority can be interrupted by a DPC, could lead to different lagging problems). The solution:
Threaded DPCs - a DPC that runs at PASSIVE_LEVEL IRQL as a real time thread (thread priority of 32), this allows the DPC to still be prioritized over most UM threads
(they do not run at the same priority) but also allows nonthreaded DPCs, APCs and higher priority threads to execute before this threaded DPC.

# Credits:
this whole entry was based on the blog https://www.sysnative.com/forums/threads/dpcs-and-apcs.11076/, as well as the APCs entry which helped me understand these 
topics better
